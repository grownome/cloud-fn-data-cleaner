{"version":3,"file":"promesa.core.js","sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/Promise","promesa.impl/Promise","promesa.core/schedule","ms","func","promesa.impl.scheduler/schedule","promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/promise","promesa.protocols/-promise","promesa.core/promise?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/map","f","promesa.protocols/-map","promesa.core/mapcat","promesa.protocols/-bind","promesa.core/bind","promesa.core/then","var_args","args__6412__auto__","len__6405__auto__","i__6406__auto__","argseq__6413__auto__","cljs.core/IndexedSeq","promesa.core/chain","seq32601","G__32602","cljs.core/first","cljs.core/next","funcs","p1__32599#","p2__32600#","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","promesa.core/branch","success","failure","promesa.protocols/-catch","G__32655","promesa.core/catch","js/Error","pred-or-type","accept?","p1__32653#","cljs.core/ifn?","e","G__32671","promesa.core/error","promesa.core.catch$.cljs$core$IFn$_invoke$arity$2","type","promesa.core.catch$.cljs$core$IFn$_invoke$arity$3","promesa.core/err","promesa.core/finally","callback","promesa.core/all","promises","cljs.core.into_array.cljs$core$IFn$_invoke$arity$1","cljs.core/vec","promesa.core/any","promesa.core/cancel!","promesa.protocols/-cancel","promesa.core/cancelled?","promesa.protocols/-cancelled?","promesa.core/promisify","callable","args","resolve","reject","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","e32687","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","G__32697","promesa.core/timeout","t","G__32719","promesa.core/delay","promesa.core.delay.cljs$core$IFn$_invoke$arity$2","promesa.core/attempt","G__32725","promesa.core/await","seq32747","cljs.core/seq","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":[";; Copyright (c) 2015-2016 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise await map mapcat])\n  (:require [promesa.protocols :as pt]\n            [promesa.impl :as impl]\n            [promesa.impl.scheduler :as ps])\n  #?(:clj\n     (:import java.util.concurrent.CompletableFuture\n              java.util.concurrent.CompletionStage)))\n\n;; --- Global Constants\n\n#?(:clj\n   (defn set-executor!\n     \"Replace the default executor instance with\n     your own instance.\"\n     [executor]\n     (alter-var-root #'impl/+executor+ (constantly executor))))\n\n#?(:cljs (def ^:const Promise impl/Promise))\n\n;; --- Scheduling helpers\n\n(defn schedule\n  \"Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function.\"\n  [ms func]\n  (ps/schedule ms func))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn promise\n  \"The promise constructor.\"\n  [v]\n  (pt/-promise v))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? Promise v)))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn map\n  \"Apply a function to the promise value and\n  return a new promise with the result.\"\n  [f p]\n  (pt/-map p f))\n\n(defn mapcat\n  \"Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator.\"\n  [f p]\n  (pt/-bind p f))\n\n(defn bind\n  \"A chain helper for promises.\"\n  [p f]\n  (pt/-bind p f))\n\n(defn then\n  \"Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`.\"\n  [p f]\n  #?(:cljs (pt/-map p f)\n     :clj  (pt/-bind p (fn promise-wrap [in]\n                         (let [out (f in)]\n                           (if (promise? out)\n                             out\n                             (promise out)))))))\n\n(defn chain\n  \"Like then but accepts multiple parameters.\"\n  [p & funcs]\n  (reduce #(then %1 %2) p funcs))\n\n(defn branch\n  [p success failure]\n  (-> p\n      (pt/-map success)\n      (pt/-catch failure)))\n\n(defn catch\n  \"Catch all promise chain helper.\"\n  ([p f]\n   (pt/-catch p f))\n  ([p pred-or-type f]\n   (let [accept? (if (ifn? pred-or-type)\n                   pred-or-type\n                   #(instance? pred-or-type %))]\n     (pt/-catch p (fn [e]\n                    (if (accept? e)\n                      (f e)\n                      (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn finally\n  \"Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected.\"\n  [p callback]\n  #?(:clj (-> p\n              (then (fn [_] (callback)))\n              (catch (fn [_] (callback))))\n     :cljs (.lastly p callback)))\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all Promise (into-array promises))\n               (then vec))\n     :clj (let [promises (clojure.core/map pt/-promise promises)]\n            (then (->> (into-array CompletableFuture promises)\n                       (CompletableFuture/allOf))\n                  (fn [_]\n                    (mapv pt/-extract promises))))))\n\n(defn any\n  \"Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled.\"\n  [promises]\n  #?(:cljs (.any Promise (into-array promises))\n     :clj (->> (clojure.core/map pt/-promise promises)\n               (into-array CompletableFuture)\n               (CompletableFuture/anyOf))))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (promise (fn [resolve reject]\n               (let [args (-> (vec args)\n                              (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                       (reject e))))))))\n\n#?(:cljs\n   (defn timeout\n     \"Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError\"\n     ([p t] (.timeout p t))\n     ([p t v] (.timeout p t v))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.\"\n  ([t] (delay t nil))\n  ([t v]\n   #?(:cljs (promise (fn [resolve reject]\n                       (schedule t #(resolve v))))\n\n      :clj  (let [p (CompletableFuture.)]\n              (schedule t #(.complete p v))\n              p))))\n\n(defn attempt\n  \"A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback.\"\n  [callback]\n  #?(:cljs (promise (fn [resolve] (resolve (callback))))\n     :clj  (promise (fn [resolve reject]\n                      (let [result (callback)]\n                        (if (promise? result)\n                          (then result resolve)\n                          (resolve result)))))))\n\n#?(:clj\n   (defmacro do*\n     \"A sugar syntax on top of `attempt`.\"\n     [& body]\n     `(attempt #(do ~@body))))\n\n(defn await\n  [& args]\n  (throw (ex-info \"Should be only used in alet macro.\" {})))\n\n#?(:clj\n   (defmacro alet\n     \"A `let` alternative that always returns promise and allows\n     use `await` marker function in order to emulate the async/await\n     syntax and make the let expression look like synchronous where\n     async operations are performed.\"\n     [bindings & body]\n     (let [await# `await]\n       (->> (reverse (partition 2 bindings))\n            (reduce (fn [acc [l r]]\n                      (if (and (coll? r)\n                               (symbol? (first r))\n                               (not= \".\" (subs (name (first r)) 0 1)))\n                        `(if (= ~await# ~(first r))\n                           (bind ~(second r) (fn [~l] ~acc))\n                           (let [~l ~r] ~acc))\n                        `(let [~l ~r] ~acc)))\n                    `(promise (do ~@body)))))))\n"]}